precision mediump float;

uniform vec2 u_pov;
uniform float u_lookAngle;

// (map columns, map rows)
uniform vec2 u_mapSize;

// projection distance / canvas height
uniform float u_wallScale;

uniform float u_halfFov;

uniform sampler2D u_map;

attribute vec4 a_position;

varying vec2 v_texPosition;

const float STEP_SIZE = 0.01;
const int MAX_DISTANCE = 1000;

void main() {
  gl_Position = vec4(a_position.xy, 0.0, 1.0);

  float rayAngle = u_lookAngle + a_position.x * u_halfFov;

  vec2 step = vec2(cos(rayAngle), sin(rayAngle)) * STEP_SIZE;
  vec2 pos = u_pov + step;

  for (int i = 0; i < MAX_DISTANCE; i++) {
    vec4 color = texture2D(u_map, pos / u_mapSize);
    if (color.r > 0.5) {
      float distance =
        sin(u_lookAngle) * (pos.y - u_pov.y) +
        cos(u_lookAngle) * (pos.x - u_pov.x);
      float height = u_wallScale / distance;
      vec2 newPosition = vec2(a_position.x, height * 0.5 * sign(a_position.y));
      gl_Position = vec4(newPosition, 0.0, 1.0);

      v_texPosition = vec2(pos.x / 32.0 - floor(pos.x / 32.0), 1.0 - (a_position.y + 1.0) / 2.0);

      return;
    }
    pos += step;
  }
}
